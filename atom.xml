<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lizehua0127的博客</title>
  <icon>https://www.gravatar.com/avatar/76235fd619c98ddd4a86f86312ef7805</icon>
  <subtitle>默默开发的程序员</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lizehua0127.github.io/"/>
  <updated>2019-04-07T15:47:16.164Z</updated>
  <id>https://lizehua0127.github.io/</id>
  
  <author>
    <name>lizehua0127</name>
    <email>guaiwula@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>EventBus源码解析</title>
    <link href="https://lizehua0127.github.io/2018/08/02/diary-2018-0802/"/>
    <id>https://lizehua0127.github.io/2018/08/02/diary-2018-0802/</id>
    <published>2018-08-02T13:36:00.000Z</published>
    <updated>2019-04-07T15:47:16.164Z</updated>
    
    <content type="html"><![CDATA[<p>EventBus是Android很火的一个事件分发框架，能让Android开发中的消息事件得到了解偶。现在我们通过源码解读来探究下这个框架到底是怎么实现和进行工作的。</p><p>EventBus项目地址：<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">https://github.com/greenrobot/EventBus</a></p><p>EventBus的源码不多，我们主要可以通过它的创建、订阅、发布消息、接触订阅这4个方面下手。<br><a id="more"></a></p><h3 id="EventBus的创建"><a href="#EventBus的创建" class="headerlink" title="EventBus的创建"></a>EventBus的创建</h3><p>使用过EventBus的同学都知道，通过EventBus.getDefault()就可以得到一个EventBus的实例对象了，下面我们看下里面到底做了什么。</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Convenience singleton for apps using a process-wide EventBus instance. */</span></span><br><span class="line">   <span class="comment">// 其实是通过单例的形式来创建了对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EventBus getDefault() &#123;</span><br><span class="line">        <span class="keyword">if</span> (defaultInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (EventBus.<span class="keyword">class</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (defaultInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    defaultInstance = <span class="keyword">new</span> EventBus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> defaultInstance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面看看<code>new EventBus()</code>做了什么</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EventBus的构造函数通过传入一个默认的EventBusBuilder来创建实例</span></span><br><span class="line"><span class="comment">// private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_BUILDER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EventBus的构造函通过建造者模式来完成对象的初始化</span></span><br><span class="line"> EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">    logger = builder.getLogger(); <span class="comment">// 获取默认的日志器</span></span><br><span class="line">    <span class="comment">// 订阅方法存储 ：Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; ，</span></span><br><span class="line">    <span class="comment">// key是消息类的类型，value是一个线程安全的集合，存放该类型消息的订阅者</span></span><br><span class="line">    subscriptionsByEventType = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册的类型map ：Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt;</span></span><br><span class="line">    <span class="comment">// key 是注册的类 如 Activity，value是消息的类型</span></span><br><span class="line">    typesBySubscriber = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 粘性消息事件的map</span></span><br><span class="line">    <span class="comment">// key是消息的类如event.getClass() ， value是event</span></span><br><span class="line">    stickyEvents = <span class="keyword">new</span> <span class="type">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 里面封装了主线程的looper，支持线程的判断是否是主线程</span></span><br><span class="line">    mainThreadSupport = builder.getMainThreadSupport();</span><br><span class="line">    <span class="comment">// 一个拥有主线长looper的Handler，用来分发事件消息的</span></span><br><span class="line">    mainThreadPoster = mainThreadSupport != <span class="literal">null</span> ? mainThreadSupport.createPoster(<span class="built_in">this</span>) : <span class="type">null</span>;</span><br><span class="line">    <span class="comment">// 在后台发布消息的poster， 实现Runnable的接口，里面使用了synchronized</span></span><br><span class="line">    backgroundPoster = <span class="keyword">new</span> <span class="type">BackgroundPoster</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 在后台发布消息的poster， 实现Runnable的接口，</span></span><br><span class="line">    asyncPoster = <span class="keyword">new</span> <span class="type">AsyncPoster</span>(<span class="built_in">this</span>);</span><br><span class="line">    </span><br><span class="line">    indexCount = builder.subscriberInfoIndexes != <span class="literal">null</span> ? builder.subscriberInfoIndexes.size() : <span class="type">0</span>;</span><br><span class="line">    <span class="comment">// 订阅方法的解析者，负责通过订阅的类，把类中的订阅的方法给解析出来</span></span><br><span class="line">    subscriberMethodFinder = <span class="keyword">new</span> <span class="type">SubscriberMethodFinder</span>(builder.subscriberInfoIndexes,</span><br><span class="line">            builder.strictMethodVerification, builder.ignoreGeneratedIndex);</span><br><span class="line">            </span><br><span class="line">    logSubscriberExceptions = builder.logSubscriberExceptions;  <span class="comment">// 是否打印异常</span></span><br><span class="line">    logNoSubscriberMessages = builder.logNoSubscriberMessages;  <span class="comment">// 是否打印没有订阅的消息</span></span><br><span class="line">    sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent; <span class="comment">// 是否打印订阅者异常事件</span></span><br><span class="line">    sendNoSubscriberEvent = builder.sendNoSubscriberEvent;      <span class="comment">// 是否发送没有订阅的事件</span></span><br><span class="line">    throwSubscriberException = builder.throwSubscriberException;   <span class="comment">// 是否抛异常 </span></span><br><span class="line">    eventInheritance = builder.eventInheritance;            <span class="comment">// 是否检测事件的父类与接口，符合条件的也会触发消息发送</span></span><br><span class="line">    <span class="comment">//  线程池</span></span><br><span class="line">    executorService = builder.executorService;          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上基本把EventBus的初始化都看完了，下面我们可以做个总结：</p><p>1、EventBus可以通过EventBus.getDefault()初始化实例，该方法得到的是一个单例</p><p>2、EventBus的创建是通过建造者模式创建的，创建是，会有很多的配置进行初始化</p><p>3、EventBus可以自定义配置，<code>EventBus.builder().build();</code>的形式来完成自定义配置创建</p><p>4、不同的EventBus的实例内的订阅是不互通的</p><h3 id="EventBus的订阅者注册"><a href="#EventBus的订阅者注册" class="headerlink" title="EventBus的订阅者注册"></a>EventBus的订阅者注册</h3><p>一般我们会在一个Activity中写订阅函数，并在onStart()方法中注册订阅者`EventBus.getDefault().register(this);</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅函数如下</span></span><br><span class="line"><span class="comment">// 可以配置线程模式，是否是粘性消息，和消息的权重</span></span><br><span class="line">@Subscribe(threadMode = ThreadMode.MAIN, sticky = <span class="literal">true</span>, priority = <span class="number">100</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subescribeMsg</span>(<span class="params">MessageEvent <span class="keyword">event</span></span>) </span>&#123;</span><br><span class="line">    Log.i(<span class="string">"MainActivity"</span>, <span class="string">"get msg = "</span> + <span class="keyword">event</span>.msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们通过<code>EventBus.getDefault().register(this);</code>这个方法的入口，看看里面到底怎么完成注册的</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">public</span> void register(Object <span class="keyword">subscriber) </span>&#123;</span><br><span class="line">    // 该方法主要做两件事 </span><br><span class="line">    Class&lt;?&gt; <span class="keyword">subscriberClass </span>= <span class="keyword">subscriber.getClass();</span></span><br><span class="line"><span class="keyword"> </span>   // <span class="number">1</span>、获取所有的订阅方法</span><br><span class="line">    List&lt;<span class="keyword">SubscriberMethod&gt; </span><span class="keyword">subscriberMethods </span>= <span class="keyword">subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span></span><br><span class="line"><span class="keyword"> </span>   synchronized (this) &#123;</span><br><span class="line">        // <span class="number">2</span>、将所有的订阅方法保存</span><br><span class="line">        for (<span class="keyword">SubscriberMethod </span><span class="keyword">subscriberMethod </span>: <span class="keyword">subscriberMethods) </span>&#123;</span><br><span class="line">            <span class="keyword">subscribe(subscriber, </span><span class="keyword">subscriberMethod);</span></span><br><span class="line"><span class="keyword"> </span>       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取所有订阅方法"><a href="#获取所有订阅方法" class="headerlink" title="获取所有订阅方法"></a>获取所有订阅方法</h4><p>我们发现，EventBus获取订阅方法的任务是交给SubscriberMethodFinder这个类完成，通过分析subscriberMethodFinder.findSubscriberMethods(subscriberClass)看看他是怎么获取订阅函数的</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">List</span>&lt;<span class="keyword">SubscriberMethod&gt; </span>findSubscriberMethods(Class&lt;?&gt; <span class="keyword">subscriberClass) </span>&#123;</span><br><span class="line">    // <span class="number">1</span>、 先通过METHOD_CACHE缓存获取</span><br><span class="line">    List&lt;<span class="keyword">SubscriberMethod&gt; </span><span class="keyword">subscriberMethods </span>= METHOD_CACHE.get(<span class="keyword">subscriberClass);</span></span><br><span class="line"><span class="keyword"> </span>   <span class="meta">if</span> (<span class="keyword">subscriberMethods </span>!= null) &#123;</span><br><span class="line">        return <span class="keyword">subscriberMethods;</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class="line">    // <span class="number">2</span>、 通过反射</span><br><span class="line">        <span class="keyword">subscriberMethods </span>= findUsingReflection(<span class="keyword">subscriberClass);</span></span><br><span class="line"><span class="keyword"> </span>   &#125; <span class="meta">else</span> &#123;</span><br><span class="line">    // <span class="number">3</span>、 通过事先生成好的订阅消息类（该类是通过注解处理器在编译期生成的）后面会另外讨论这个</span><br><span class="line">        <span class="keyword">subscriberMethods </span>= findUsingInfo(<span class="keyword">subscriberClass);</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">    <span class="meta">if</span> (<span class="keyword">subscriberMethods.isEmpty()) </span>&#123;</span><br><span class="line">        throw new EventBusException(<span class="string">"Subscriber "</span> + <span class="keyword">subscriberClass</span></span><br><span class="line"><span class="keyword"> </span>               + <span class="string">" and its super classes have no public methods with the @Subscribe annotation"</span>)<span class="comment">;</span></span><br><span class="line">    &#125; <span class="meta">else</span> &#123;</span><br><span class="line">        METHOD_CACHE.put(<span class="keyword">subscriberClass, </span><span class="keyword">subscriberMethods);</span></span><br><span class="line"><span class="keyword"> </span>       return <span class="keyword">subscriberMethods;</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、SubscriberMethodFinder先从缓存中获取该类的所有订阅方法</p><p>2、如果反射没有，可以通过反射的形式获取</p><p>3、也可以从预先建好的subscriberInfoIndexes中获取，这种方式是可以避免反射带来的性能消耗。如果没有找到，还是会通过反射获取</p><p>4、最后会将找到的订阅函数缓存，key是订阅类类型，value是List<subscribermethod>订阅方法的集合</subscribermethod></p><h4 id="将所有订阅方法注册到Map中"><a href="#将所有订阅方法注册到Map中" class="headerlink" title="将所有订阅方法注册到Map中"></a>将所有订阅方法注册到Map中</h4><p>我们查看EventBus的subscribe(Object subscriber, SubscriberMethod subscriberMethod)</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// 当得到订阅者中所有的订阅方法后，通过遍历，将订阅方法方法一个一个注册</span><br><span class="line">  // Must <span class="keyword">be </span>called in synchronized <span class="keyword">block</span></span><br><span class="line"><span class="keyword">private </span>void <span class="keyword">subscribe(Object </span><span class="keyword">subscriber, </span><span class="keyword">SubscriberMethod </span><span class="keyword">subscriberMethod) </span>&#123;</span><br><span class="line">    Class&lt;?&gt; eventType = <span class="keyword">subscriberMethod.eventType;</span></span><br><span class="line"><span class="keyword"> </span>   // <span class="keyword">Subscription中封装了订阅者与一个订阅函数</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">Subscription </span>newSubscription = new <span class="keyword">Subscription(subscriber, </span><span class="keyword">subscriberMethod);</span></span><br><span class="line"><span class="keyword"> </span>   CopyOnWriteArrayList&lt;<span class="keyword">Subscription&gt; </span><span class="keyword">subscriptions </span>= <span class="keyword">subscriptionsByEventType.get(eventType);</span></span><br><span class="line"><span class="keyword"> </span>   <span class="meta">if</span> (<span class="keyword">subscriptions </span>== null) &#123;</span><br><span class="line">        <span class="keyword">subscriptions </span>= new CopyOnWriteArrayList&lt;&gt;()<span class="comment">;</span></span><br><span class="line">        // 在<span class="keyword">subscriptionsByEventType </span>的<span class="meta">map</span>中，保存key是消息事件类类型，value是<span class="keyword">Subscription的集合</span></span><br><span class="line"><span class="keyword"> </span>       <span class="keyword">subscriptionsByEventType.put(eventType, </span><span class="keyword">subscriptions);</span></span><br><span class="line"><span class="keyword"> </span>   &#125; <span class="meta">else</span> &#123;</span><br><span class="line">        <span class="meta">if</span> (<span class="keyword">subscriptions.contains(newSubscription)) </span>&#123;</span><br><span class="line">            throw new EventBusException(<span class="string">"Subscriber "</span> + <span class="keyword">subscriber.getClass() </span>+ <span class="string">" already registered to event "</span></span><br><span class="line">                    + eventType)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int size = <span class="keyword">subscriptions.size();</span></span><br><span class="line"><span class="keyword"> </span>   for (int i = <span class="number">0</span><span class="comment">; i &lt;= size; i++) &#123;</span></span><br><span class="line">        <span class="meta">if</span> (i == size <span class="title">||</span> <span class="keyword">subscriberMethod.priority </span>&gt; <span class="keyword">subscriptions.get(i).subscriberMethod.priority) </span>&#123;</span><br><span class="line">        // 根据订阅函数的优先级来保存在<span class="keyword">Subscription的集合中</span></span><br><span class="line"><span class="keyword"> </span>           <span class="keyword">subscriptions.add(i, </span>newSubscription)<span class="comment">;</span></span><br><span class="line">            <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"> </span>       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 在typesBySubscriber <span class="meta">map</span>中保存， key是订阅者，value是订阅消息类类型</span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; <span class="keyword">subscribedEvents </span>= typesBySubscriber.get(<span class="keyword">subscriber);</span></span><br><span class="line"><span class="keyword"> </span>   <span class="meta">if</span> (<span class="keyword">subscribedEvents </span>== null) &#123;</span><br><span class="line">        <span class="keyword">subscribedEvents </span>= new ArrayList&lt;&gt;()<span class="comment">;</span></span><br><span class="line">        typesBySubscriber.put(<span class="keyword">subscriber, </span><span class="keyword">subscribedEvents);</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">    <span class="keyword">subscribedEvents.add(eventType);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>   <span class="meta">if</span> (<span class="keyword">subscriberMethod.sticky) </span>&#123;</span><br><span class="line">        // 如果是粘性的订阅函数，从粘性消息事件中获取消息直接发送</span><br><span class="line">        <span class="meta">if</span> (eventInheritance) &#123;</span><br><span class="line">            // Existing sticky events of all <span class="keyword">subclasses </span>of eventType have to <span class="keyword">be </span>considered.</span><br><span class="line">            // Note: <span class="keyword">Iterating </span>over all events may <span class="keyword">be </span>inefficient with lots of sticky events,</span><br><span class="line">            // thus <span class="meta">data</span> <span class="keyword">structure </span>should <span class="keyword">be </span>changed to allow a more efficient lookup</span><br><span class="line">            // (e.g. an <span class="keyword">additional </span><span class="meta">map</span> storing <span class="keyword">sub </span>classes of super classes: Class -&gt; List&lt;Class&gt;).</span><br><span class="line">            Set&lt;<span class="meta">Map</span>.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet()<span class="comment">;</span></span><br><span class="line">            for (<span class="meta">Map</span>.Entry&lt;Class&lt;?&gt;, Object&gt; <span class="meta">entry</span> : entries) &#123;</span><br><span class="line">                Class&lt;?&gt; candidateEventType = <span class="meta">entry</span>.getKey()<span class="comment">;</span></span><br><span class="line">                <span class="meta">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                    Object stickyEvent = <span class="meta">entry</span>.getValue()<span class="comment">;</span></span><br><span class="line">                    checkPostStickyEventToSubscription(newSubscription, stickyEvent)<span class="comment">;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="meta">else</span> &#123;</span><br><span class="line">            Object stickyEvent = stickyEvents.get(eventType)<span class="comment">;</span></span><br><span class="line">            checkPostStickyEventToSubscription(newSubscription, stickyEvent)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、保存在subscriptionsByEventType的map中，key是消息事件类型（订阅者接收参数的类型），value是Subscription的有序集合（更具订阅函数的优先级排序），Subscription中封装了订阅者（Activity）和订阅函数</p><p>2、保存在subscribedEvents的map中，key是订阅者对象，value是订阅的消息类型集合</p><p>3、如果是粘性的订阅函数，会先触发粘性的消息发送</p><h3 id="EventBus的消息发布"><a href="#EventBus的消息发布" class="headerlink" title="EventBus的消息发布"></a>EventBus的消息发布</h3><p>EventBus有两种发布消息的方法1、EventBus.getDefault().post(“”); 2、EventBus.getDefault().postSticky(“”);</p><h4 id="post"><a href="#post" class="headerlink" title="post()"></a>post()</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Posts the given event to the event bus. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span>(<span class="params">Object <span class="keyword">event</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//PostingThreadState 是ThreadLocal实例，通过get得到一个PostingThreadState对象，该对象中有一个事件队列</span></span><br><span class="line">    <span class="comment">// 这样做，可以保证一个线程只会得到一个PostingThreadState对象</span></span><br><span class="line">    PostingThreadState postingState = currentPostingThreadState.<span class="keyword">get</span>();</span><br><span class="line">    <span class="comment">// 将事件存入该线程的消息队列</span></span><br><span class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">    eventQueue.<span class="keyword">add</span>(<span class="keyword">event</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">        <span class="comment">// 是否是主线程</span></span><br><span class="line">        postingState.isMainThread = isMainThread();</span><br><span class="line">        postingState.isPosting = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//分发消息</span></span><br><span class="line">                postSingleEvent(eventQueue.<span class="keyword">remove</span>(<span class="number">0</span>), postingState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            postingState.isPosting = <span class="literal">false</span>;</span><br><span class="line">            postingState.isMainThread = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分发消息函数 postSingleEvent</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span>(<span class="params">Object <span class="keyword">event</span>, PostingThreadState postingState</span>) throws Error </span>&#123;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 获取事件的类型</span></span><br><span class="line">     Class&lt;?&gt; eventClass = <span class="keyword">event</span>.getClass();</span><br><span class="line">     boolean subscriptionFound = <span class="literal">false</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 查找并分发消息</span></span><br><span class="line">     postSingleEventForEventType(<span class="keyword">event</span>, postingState, eventClass);</span><br><span class="line">     <span class="comment">// 。。。。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> boolean <span class="title">postSingleEventForEventType</span>(<span class="params">Object <span class="keyword">event</span>, PostingThreadState postingState, Class&lt;?&gt; eventClass</span>) </span>&#123;</span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">    synchronized (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过subscriptionsByEventType的map获取所有注册的订阅</span></span><br><span class="line">        subscriptions = subscriptionsByEventType.<span class="keyword">get</span>(eventClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="literal">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">        <span class="comment">// 略。。。。。。</span></span><br><span class="line">        <span class="comment">// 分发消息</span></span><br><span class="line">            postToSubscription(subscription, <span class="keyword">event</span>, postingState.isMainThread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后分发消息</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span>(<span class="params">Subscription subscription, Object <span class="keyword">event</span>, boolean isMainThread</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// 通过不同的订阅函数的线程模式去分发消息</span></span><br><span class="line">     <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">         <span class="keyword">case</span> POSTING:</span><br><span class="line">             invokeSubscriber(subscription, <span class="keyword">event</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> MAIN:</span><br><span class="line">             <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                 invokeSubscriber(subscription, <span class="keyword">event</span>);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 mainThreadPoster.enqueue(subscription, <span class="keyword">event</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> MAIN_ORDERED:</span><br><span class="line">             <span class="keyword">if</span> (mainThreadPoster != <span class="literal">null</span>) &#123;</span><br><span class="line">                 mainThreadPoster.enqueue(subscription, <span class="keyword">event</span>);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// temporary: technically not correct as poster not decoupled from subscriber</span></span><br><span class="line">                 invokeSubscriber(subscription, <span class="keyword">event</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">             <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                 backgroundPoster.enqueue(subscription, <span class="keyword">event</span>);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 invokeSubscriber(subscription, <span class="keyword">event</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> ASYNC:</span><br><span class="line">             asyncPoster.enqueue(subscription, <span class="keyword">event</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>1、从ThreadLocal中获取当前线程的PostingThreadState，里面有消息的队列，消息发布状态等信息</p><p>2、将消息保存队列中，并通过遍历队列分发消息</p><p>3、通过消息类型从subscriptionsByEventType的map获取所有注册的订阅，遍历发送</p><p>4、发送时会根据不同的订阅线程模式去选择线程发消息</p><h4 id="postSticky"><a href="#postSticky" class="headerlink" title="postSticky()"></a>postSticky()</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将粘性消息保存在stickyEvents map中，并调用post()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postSticky</span>(<span class="params">Object <span class="keyword">event</span></span>) </span>&#123;</span><br><span class="line">    synchronized (stickyEvents) &#123;</span><br><span class="line">        stickyEvents.put(<span class="keyword">event</span>.getClass(), <span class="keyword">event</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Should be posted after it is putted, in case the subscriber wants to remove immediately</span></span><br><span class="line">    post(<span class="keyword">event</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EventBus解除注册"><a href="#EventBus解除注册" class="headerlink" title="EventBus解除注册"></a>EventBus解除注册</h3><p>下面我们看看最后的解除注册unregister()</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Unregisters the given subscriber from all event classes. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> unregister(<span class="keyword">Object</span> subscriber) &#123;</span><br><span class="line">    <span class="comment">// 通过typesBySubscriber获取订阅者所订阅的类型，typesBySubscriber我们终于找到了使用的地方了</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.<span class="built_in">get</span>(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">        <span class="comment">// 遍历所有类型，并调研unsubscribeByEventType</span></span><br><span class="line">            unsubscribeByEventType(subscriber, eventType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从typesBySubscriber中移除</span></span><br><span class="line">        typesBySubscriber.remove(subscriber);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.<span class="built_in">log</span>(Level.WARNING, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> unsubscribeByEventType(<span class="keyword">Object</span> subscriber, Class&lt;?&gt; eventType) &#123;</span><br><span class="line">    <span class="comment">// 通过类型找到所有的subscriptions，如果subscriptions里的subscriber是该需要解除组册的，就将该subscription从数组中移除</span></span><br><span class="line">    List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.<span class="built_in">get</span>(eventType);</span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">size</span> = subscriptions.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">            Subscription subscription = subscriptions.<span class="built_in">get</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</span><br><span class="line">                subscription.active = <span class="keyword">false</span>;</span><br><span class="line">                subscriptions.remove(i);</span><br><span class="line">                i--;</span><br><span class="line">                <span class="built_in">size</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、通过订阅者从typesBySubscriber中获取所有消息类型</p><p>2、通过消息类型再从subscriptionsByEventType中移除对应的订阅信息</p><p>3、最后从typesBySubscriber中移除订阅者</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;EventBus是Android很火的一个事件分发框架，能让Android开发中的消息事件得到了解偶。现在我们通过源码解读来探究下这个框架到底是怎么实现和进行工作的。&lt;/p&gt;
&lt;p&gt;EventBus项目地址：&lt;a href=&quot;https://github.com/greenrobot/EventBus&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/greenrobot/EventBus&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;EventBus的源码不多，我们主要可以通过它的创建、订阅、发布消息、接触订阅这4个方面下手。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://lizehua0127.github.io/tags/Android/"/>
    
      <category term="源码" scheme="https://lizehua0127.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Android的So文件加载路径动态修改方案</title>
    <link href="https://lizehua0127.github.io/2017/08/22/diary-2017-0822/"/>
    <id>https://lizehua0127.github.io/2017/08/22/diary-2017-0822/</id>
    <published>2017-08-22T02:36:00.000Z</published>
    <updated>2019-04-02T16:21:58.853Z</updated>
    
    <content type="html"><![CDATA[<p>​    我们都知道，Android开发中，加载so文件使用的方法是<strong>System.loadLibrary()</strong>,Android会自动的帮助我们去加载app的so文件。</p><a id="more"></a><p>​    apk安装后的so文件释放路径为：<br>系统app：/system/lib64/ | /system/lib/<br>第三方app：/data/app-lib/XXX/<br>​    Android会去这些默认的路径中加载so文件。但是如果我们有的so文件没在这些路径下，或者需要动态去别地路径加载so文件，那该怎么办呢？</p><h2 id="修改默认的路径"><a href="#修改默认的路径" class="headerlink" title="修改默认的路径"></a>修改默认的路径</h2><p>​    通过阅读System.loadLibrary方法源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// System 类的loadLibrary发现是调用Runtime.getRuntime().loadLibrary()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libname)</span> </span>&#123;</span><br><span class="line">Runtime.getRuntime().loadLibrary(VMStack.getCallingClassLoader(), libname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    继续跟进Runtime</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> loadLibrary(<span class="built_in">String</span> libraryName, ClassLoader loader) &#123;</span><br><span class="line">     <span class="comment">// 重点是查看路径是怎么得到的</span></span><br><span class="line">    <span class="keyword">if</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//loader 不是空 主要是下面这个函数得到</span></span><br><span class="line">        <span class="built_in">String</span> filename = loader.findLibrary(libraryName);</span><br><span class="line">        <span class="comment">// 。。。。 略</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//loader 是空 主要是下面这个函数得到</span></span><br><span class="line">    <span class="built_in">String</span> filename = System.mapLibraryName(libraryName);</span><br><span class="line">    <span class="comment">// 。。。。 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一、跟进ClassLoader.findLibrary，其实是子类BaseDexClassLoader.findLibrary</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">String <span class="title">findLibrary</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> pathList.<span class="title">findLibrary</span><span class="params">(name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进DexPathList.findLibrary</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> findLibrary(<span class="keyword">String</span> libraryName) &#123;</span><br><span class="line">    <span class="comment">// 这里与一开始的分支一样的方法</span></span><br><span class="line">    <span class="keyword">String</span> fileName = System.mapLibraryName(libraryName);</span><br><span class="line">    <span class="comment">// 从nativeLibraryDirectories中获取路径</span></span><br><span class="line">    <span class="built_in">for</span> (<span class="built_in">File</span> directory : nativeLibraryDirectories) &#123;</span><br><span class="line">        <span class="keyword">String</span> path = <span class="keyword">new</span> <span class="built_in">File</span>(directory, fileName).getPath();</span><br><span class="line">        <span class="built_in">if</span> (IoUtils.canOpenReadOnly(path)) &#123;</span><br><span class="line">            <span class="built_in">return</span> path;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析到这里，我们来终结下</p><p>其实System.loadLibrary方法调用Runtime.getRuntime().loadLibrary()，再通过BaseDexClassLoader.findLibrary去获取so的路径，而路径就存在BaseDexClassLoader.pathList 对象的nativeLibraryDirectories中，所以我们只要通过反射动态的在nativeLibraryDirectories添加我们要指定的路径，System.loadLibrary就能加载指定文件夹下的so文件了</p><p>二、跟进System.mapLibraryName</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the platform specific file name format for the shared library</span></span><br><span class="line"><span class="comment"> * named by the argument. On Android, this would turn &#123;<span class="doctag">@code</span> "MyLibrary"&#125; into</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> "libMyLibrary.so"&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//这个方法调用的是native函数，其实就是将名字进行修改，如MyLibrary变成libMyLibrary.so</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="function">String <span class="title">mapLibraryName</span><span class="params">(String nickname)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="修改反射方法实践"><a href="#修改反射方法实践" class="headerlink" title="修改反射方法实践"></a>修改反射方法实践</h2><p>既然已经找到了目标，我们就要进行实践了，下面是我的一个反射修改的方法，适配了android的一些版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySoFiles</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initNativeDirectory</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hasDexClassLoader()) &#123; <span class="comment">// 4.0以上系统</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SLog.d(TAG, <span class="string">"AboveEqualApiLevel14"</span>);</span><br><span class="line">                createNewNativeDirAboveEqualApiLevel14(context);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    createNewNativeDirAboveEqualApiLevel21(context);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">                    SLog.e(TAG, e1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SLog.d(TAG, <span class="string">"BelowApiLevel14"</span>);</span><br><span class="line">                createNewNativeDirBelowApiLevel14(context); <span class="comment">// 4.0以下系统</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                SLog.e(TAG, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createNewNativeDirAboveEqualApiLevel21</span><span class="params">(Context context)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IllegalAccessException, NoSuchFieldException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">            PathClassLoader pathClassLoader = (PathClassLoader) context.getClassLoader();</span><br><span class="line">            Object pathList = getPathList(pathClassLoader);</span><br><span class="line">            SLog.d(TAG, <span class="string">"maybe is android 6.0"</span>);</span><br><span class="line">            Class&lt;?&gt; elementClass = Class.forName(<span class="string">"dalvik.system.DexPathList$Element"</span>);</span><br><span class="line">            Constructor&lt;?&gt; element = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                element = elementClass.getConstructor(File.class, <span class="keyword">boolean</span>.class, File.class, DexFile.class);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                SLog.e(TAG, e);</span><br><span class="line">            &#125;</span><br><span class="line">            Object systemNativeLibraryDirectories = pathList.getClass()</span><br><span class="line">                    .getDeclaredField(<span class="string">"systemNativeLibraryDirectories"</span>);</span><br><span class="line">            Object nativeLibraryDirectories = pathList.getClass().getDeclaredField(<span class="string">"nativeLibraryDirectories"</span>);</span><br><span class="line">            Object nativeLibraryPathElements = pathList.getClass().getDeclaredField(<span class="string">"nativeLibraryPathElements"</span>);</span><br><span class="line">            ((Field) systemNativeLibraryDirectories).setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            ((Field) nativeLibraryDirectories).setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            ((Field) nativeLibraryPathElements).setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// 获取 DEXPATHList中的属性值</span></span><br><span class="line">            List&lt;File&gt; systemFiles = (List&lt;File&gt;) ((Field) systemNativeLibraryDirectories).get(pathList);</span><br><span class="line">            List&lt;File&gt; nativeFiles = (List&lt;File&gt;) ((Field) nativeLibraryDirectories).get(pathList);</span><br><span class="line">            Object[] elementFiles = (Object[]) ((Field) nativeLibraryPathElements).get(pathList);</span><br><span class="line">            Object newElementFiles = Array.newInstance(elementClass, elementFiles.length + <span class="number">1</span>);</span><br><span class="line">            systemFiles.add(context.getDir(<span class="string">"libs"</span>, Context.MODE_PRIVATE));</span><br><span class="line">            nativeFiles.add(context.getDir(<span class="string">"libs"</span>, Context.MODE_PRIVATE));</span><br><span class="line">            ((Field) systemNativeLibraryDirectories).set(pathList, systemFiles);</span><br><span class="line">            ((Field) nativeLibraryDirectories).set(pathList, nativeFiles);</span><br><span class="line">            <span class="keyword">if</span> (element != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object newInstance = element.newInstance(</span><br><span class="line">                            <span class="keyword">new</span> File(context.getDir(<span class="string">"libs"</span>, Context.MODE_PRIVATE).getAbsolutePath()), <span class="keyword">true</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                    Array.set(newElementFiles, <span class="number">0</span>, newInstance);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; elementFiles.length + <span class="number">1</span>; i++) &#123;</span><br><span class="line">                        Array.set(newElementFiles, i, elementFiles[i - <span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ((Field) nativeLibraryPathElements).set(pathList, newElementFiles);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                    SLog.e(TAG, e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                    SLog.e(TAG, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createNewNativeDirBelowApiLevel14</span><span class="params">(Context context)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        PathClassLoader pathClassLoader = (PathClassLoader) context.getClassLoader();</span><br><span class="line">        Field mLibPaths = pathClassLoader.getClass().getDeclaredField(<span class="string">"mLibPaths"</span>);</span><br><span class="line">        mLibPaths.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        String[] libs = (String[]) (mLibPaths).get(pathClassLoader);</span><br><span class="line">        Object newPaths = Array.newInstance(String.class, libs.length + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 添加自定义.so路径</span></span><br><span class="line">        Array.set(newPaths, <span class="number">0</span>, context.getDir(<span class="string">"libs"</span>, Context.MODE_PRIVATE).getAbsolutePath());</span><br><span class="line">        <span class="comment">// 将系统自己的追加上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; libs.length + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            Array.set(newPaths, i, libs[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        mLibPaths.set(pathClassLoader, newPaths);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createNewNativeDirAboveEqualApiLevel14</span><span class="params">(Context context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PathClassLoader pathClassLoader = (PathClassLoader) context.getClassLoader();</span><br><span class="line">        Object pathList = getPathList(pathClassLoader);</span><br><span class="line">        <span class="comment">// 获取当前类的属性</span></span><br><span class="line">        Object nativeLibraryDirectories = pathList.getClass().getDeclaredField(<span class="string">"nativeLibraryDirectories"</span>);</span><br><span class="line">        ((Field) nativeLibraryDirectories).setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 获取 DEXPATHList中的属性值</span></span><br><span class="line">        File[] files = (File[]) ((Field) nativeLibraryDirectories).get(pathList);</span><br><span class="line">        Object newfiles = Array.newInstance(File.class, files.length + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 添加自定义.so路径</span></span><br><span class="line">        Array.set(newfiles, <span class="number">0</span>, context.getDir(<span class="string">"libs"</span>, Context.MODE_PRIVATE));</span><br><span class="line">        <span class="comment">// 将系统自己的追加上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; files.length + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            Array.set(newfiles, i, files[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        ((Field) nativeLibraryDirectories).set(pathList, newfiles);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">getPathList</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getField(obj, Class.forName(<span class="string">"dalvik.system.BaseDexClassLoader"</span>), <span class="string">"pathList"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">getField</span><span class="params">(Object obj, Class cls, String str)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        Field declaredField = cls.getDeclaredField(str);</span><br><span class="line">        declaredField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> declaredField.get(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasDexClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"dalvik.system.BaseDexClassLoader"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var1) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    我们都知道，Android开发中，加载so文件使用的方法是&lt;strong&gt;System.loadLibrary()&lt;/strong&gt;,Android会自动的帮助我们去加载app的so文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://lizehua0127.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
